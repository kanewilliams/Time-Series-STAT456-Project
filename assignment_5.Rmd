---
title: "Assignment 5 - Decomposing New Zealand Electrical Demand using stl(), mstl(), and STR()"
author: "Kane Williams (pkw21@uclive.ac.nz)"
output:
  bookdown::pdf_document2:
    latex_engine: xelatex
    toc: true
  bookdown::html_document2:
    toc: true
    toc_float: true
    highlight: tango
    theme: flatly
header-includes: 
- \usepackage{amsmath}
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
subtitle: "STAT456-24S2 - Time Series and Stochastic Processes"
editor_options:
  markdown:
    wrap: 72
---

```{r echo=FALSE}
source("./src/packages.R")
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
```

# Introduction

For this assignment, a 10-week period of New Zealand's historical
electricity demand will be decomposed using three different methods,
`stl()`, `mstl()`, and `STR()`.

The resulting decompositions will be compared (i) by the features
extracted, (ii) through an analysis of the residuals, and (iii) through
their time taken to run.

It will be discovered that neither class of technique is a replacement for the
other. LOESS-based techniques like `stl()` and `mstl()` are possibly better for local anomaly detection,
and `STR()` is possibly better at picking up 'interaction' effects
between days and weeks. While the LOESS-based techniques are certainly faster, `STR()` has the advantage of being able to easily form confidence intervals. Both techniques belong in the analyst's
toolkit since ultimately both of them pick out different features of the
data.

## Electricity Demand in New Zealand

New Zealand's electrical demand (two thirds of which are from households
and industry (MBIE, 2024)) is influenced by factors such as temperature,
time-of-day, day-of-the-week, day-of-the-year, and the presence of
holidays. This means that there are multiple seasonal components which potentially have
interaction effects with each other. Using the above techniques, it
will be possible to understand how each seasonal
component contributes to overall demand.

## Decomposition Techniques

Three different methods will be used in this paper. All methods decompose additively
(as will be done for this data), but a log/box-cox transformation can be
used if a multiplicative decomposition is required. Below is a brief
summary of each method. For a more technical description of each method
please see the appendix.

### `stl()`/`mstl()` - Seasonal-Trend decomposition using Loess

`stl()` from the stats package is an R function that decomposes time
series into three components: trend, seasonal, and remainder. It is
based on the work of Cleveland (1990) and works by using LOESS (Locally
Estimated Scatterplot Smoothing) to "iteratively refine estimates" of
each component. The method was designed to be (i) simple to use, (ii)
fast to compute, and (iii) allow for specifying seasonal/trend smoothing
in a continuous way. It was designed for only a single seasonal
component, although it can be adapted for multiple seasonalities either
through nested applications or by using the related `mstl()` function
from the `forecast` package. `stl()` and `mstl()` are non-parametric
methods not based on any statistical model. They just attempt to fit
smooth curves to the data.

### `STR()` - Seasonal-Trend decomposition using Regression

`STR()` from the stR package is an R function developed by Dokumentov
and Hyndman (2021) that decomposes time series into multiple seasonal
components. It is "based on a regularized optimization, and is related
to ridge regression". It attempts to address limitations in other
methods by allowing for not only multiple seasonal patterns, but also
(i) non-integer periods, (ii) complex topologies such as modelling
holidays, (iii) covariates such as temperature and the presence of
COVID-19, and even (iv) interaction effects between the seasonal
components and the covariates. Furthermore, as it is based on a
statistical model, confidence intervals can be computed.

# Data

## Data Description

The dataset chosen was: **Demand trends**, pulled on `1 October 2024`
from the [Electricity
Authority](https://www.emi.ea.govt.nz/Wholesale/Reports/W_GD_C?DateFrom=20190901&DateTo=20240831&RegionType=NZ&_rsdr=L60M&_si=_dr_DateFrom%7C20140101,_dr_DateTo%7C20231231,_dr_RegionType%7CNZ,_dr__rsdr%7CL10Y,v%7C4)
with the following parameters:

-   **Date Range**: 01 Jan 2014 - 31 Dec 2023
-   **Region Type**: New Zealand
-   **Time Scale** Trading Period (i.e. half-hourly data)

Note that the unit of measurement is GWh (Gigawatt hours).

This data will then be reduced to the 10 weeks beginning from
`5 December 2022`. This date was chosen because it (i) includes the
Christmas period, which will be a good test for how each technique deals
with "Holiday" effects, and (ii) conveniently begins on a Monday, which
may make the plots easier to interpret.

10 weeks was chosen because it is small enough that it is easy to
visually identify both weekly and daily periods, and it is large enough
to exhibit multiple-seasonality from both of these periods.

Before decomposing it, it will be useful to get a feel for the data by
plotting it (Figure 1 and 2 below) and recording any noticeable observations.

```{r echo=FALSE}
# READ data
file_path <- "./data/NZ_Electricity_Demand_2014-2023.csv"
header <- c("Period_Start", "Period_End", "Region_ID", "Region", "Price")

raw_data <- read_csv(file_path, 
                     skip = 12, 
                     col_names = header,
                     show_col_types = FALSE) %>%
  mutate(
    Price = as.numeric(Price),
    Period_Start = dmy_hms(Period_Start),
    Period_End = dmy_hms(Period_End)
  )
```

```{r echo=FALSE}
# FILTER relevant rows and columns
elec_data <- raw_data %>%
  dplyr::select(Period_Start, Price) %>%
  dplyr::filter(Period_Start >= as.Date("2022-12-05") & 
                Period_Start < as.Date("2022-12-05") + weeks(10))
```

## Time Series Plots

```{r time-series-plot, echo=FALSE, fig.cap="Plot of New Zealand Electrical Demand over Christmas '22. Source: Electricity Authority"}
ggplot(elec_data, aes(x = Period_Start, y = Price)) +
  geom_line() +
  geom_vline(xintercept = as.POSIXct("2022-12-25"), color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2022-12-25"), y = max(elec_data$Price), 
           label = "Christmas", color = "red", vjust = 2, hjust = -0.1) +
  # geom_vline(xintercept = as.POSIXct("2023-02-07"), color = "blue", linetype = "dashed", size = 0.5) +
  # annotate("text", x = as.POSIXct("2023-02-07"), y = max(elec_data$Price), 
  #          label = "Waitangi Public Holiday", color = "blue", vjust = 2, hjust = -0.1) +
  labs(
    title = "New Zealand Electrical Demand",
    subtitle = "10 weeks from December 5, 2022",
    y = "Electricity Demand (GWh)"
  ) +
  xlab("") + # no x label
  theme(
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  scale_x_datetime(date_breaks = "1 week", date_labels = "%b %d")
```

```{r time-series-plot2, echo=FALSE, fig.cap="Fully labelled NZ Electrical Demand over Christmas '22. Green line represents Wellington's Anniversary - a regional holiday - and the blue line represents Auckland's Anniversary. The pink band represents when Cyclone Gabriel may have impacted New Zealand. All holidays are labelled on the day observed."}
ggplot(elec_data, aes(x = Period_Start, y = Price)) +
  geom_rect(aes(xmin = as.POSIXct("2023-02-05"), xmax = as.POSIXct("2023-02-14"), 
              ymin = -Inf, ymax = Inf), fill = "pink", alpha = 0.2) +
  geom_line() +
  geom_vline(xintercept = as.POSIXct("2023-01-03"), color = "orange", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2023-01-03"), y = max(elec_data$Price),
           label = "New Years", color = "orange", vjust = 1, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2022-12-25"), color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2022-12-25"), y = max(elec_data$Price), 
           label = "Christmas", color = "red", vjust = 2, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2023-02-07"), color = "black", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2023-02-07"), y = max(elec_data$Price),
           label = "Waitangi", color = "black", vjust = 1, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2023-01-31"), color = "blue", linetype = "dashed", linewidth = 1) +
  # annotate("text", x = as.POSIXct("2023-01-31"), y = max(elec_data$Price),
  #          label = "Auckland Annv.", color = "blue", vjust = 2, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2023-01-24"), color = "darkgreen", linetype = "dashed", linewidth = 1) +
  # annotate("text", x = as.POSIXct("2023-01-24"), y = max(elec_data$Price),
  #          label = "Wellington Annv.", color = "darkgreen", vjust = 3, hjust = -0.1) +
  annotate("text", x = as.POSIXct("2023-02-08"), y = min(elec_data$Price),
           label = "Cyclone", color = "deeppink", vjust = -1, hjust = -0) +
  labs(
    title = "New Zealand Electrical Demand (fully labelled)",
    subtitle = "10 weeks from December 5, 2022",
    y = "Electricity Demand (GWh)"
  ) +
  xlab("") + # no x label
  theme(
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  scale_x_datetime(date_breaks = "1 week", date_labels = "%b %d")
```

**Noticeable observations**

There is clear daily and weekly seasonality present (recall that the
data begins on a Monday):

-   There is daily variation of around 0.5-1 GWh, with peaks during the
    day and troughs during the night. Furthermore, there appears to be
    smaller sub-peaks around the mornings — possibly as households start waking up — and evenings.

-   Weekly seasonality is most noticeable by the dip in demand over the
    weekends (by $\sim0.5 \texttt{GWh}$ on average). This is possibly due to industry closing down over the weekend.

As for holidays:

-   The Christmas/New Years holiday period had a very noticeable impact
    on electricity demand, with a sudden drop of around 0.5-1 GWh
    leading up to Christmas, and a gradual buildup to previous
    electricity demand in the weeks afterwards.

-   Furthermore, Waitangi day (a New Zealand public holiday) was
    observed on the 7th of February 2022. Its effect is not immediately
    obvious in the above plot, but will be made clearer with the
    decompositions.

# Method

First, results from the three decomposition methods: `stl()`, `mstl()`,
and `STR()` will be presented and briefly discussed. Since the data
shows only a mild linearly increasing trend (and only in the last 7 weeks),
an additive model will be assumed and the methods will be applied to the
raw (rather than the logged) data. Afterwards, they will be compared in
three ways:

1)  By what features they pick out,
2)  By an ACF/PACF investigation of their residuals, and
3)  By how long each method takes to run.

Lastly, practical implications will be discussed as well as possible
extensions to this analysis.

# Result

```{r echo=FALSE}

# The data is first converted to a `ts` (time series) object for `stl()`,
# and an `msts` (multi-seasonal time series) object for `mstl()` and
# `STR()`.

season_day <- 48 # day
season_week <- 48 * 7 # week
season_year <- 48 * 7 * 52.25 # year

elec_ts <- ts(elec_data$Price,
                     frequency = season_week 
)

elec_msts <- forecast::msts(as.vector(elec_data$Price), 
                             seasonal.periods = c(season_day, season_week, season_year)
)
```

## Decomposition using stl() and mstl()

Note: `stl()` and `mstl()` require setting the 'smoothing parameters'
`s.window` for the seasonal component, and `t.window` for the trend
component. The higher the smoothing window, the less variation will be
picked up. The lower the smoothing window the more variation will be
picked.

After experimenting with several combinations (see Appendix), the
default `t.window` and an `s.window` of "periodic" was decided. This
combination balanced between overfitting on variation in the data while
nevertheless capturing the overall trend and pattern.

The `s.window` and `t.window` parameters were set with the exact same
settings for `mstl()` for a fair comparison.

\newpage
\blandscape

```{r fig.width=11, fig.height=8, echo=FALSE, dpi=300, fig.cap="STL Decomposition with a weekly period, s.window=periodic"}
elec_stl <- stl(elec_ts, s.window="periodic")
elec_stl %>% autoplot() + 
  ggtitle("STL Decomposition with a weekly period, s.window=periodic") +
  theme(plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        strip.text = element_text(size = 14),
        plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"))
```

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r fig.width=11, fig.height=8, echo=FALSE, dpi=300, fig.cap="MSTL Decomposition with weekly/daily periods, s.window=periodic"}
elec_mstl <- mstl(elec_msts, s.window="periodic")
p <- elec_mstl %>% autoplot() + 
  ggtitle("MSTL Decomposition with weekly/daily periods, s.window=periodic") +
  theme(plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        strip.text = element_text(size = 14),
        plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"))

# p <- p + geom_hline(data = data.frame(parts = "Remainder", y = 0),
#                     aes(yintercept = y),
#                     linetype = "solid",
#                     color = "black")

p
```

\newpage
\elandscape

Figure 3 and Figure 4 on the previous pages show decompositions using
`stl()` and `mstl()`. (Unfortunately, the residuals are plotted differently due to how `autoplot` plots graphs. I spent some time trying to fix this, but could not get the residual-plots into the same format without affecting the trend/seasonal plots. Given more time I would try to fix this.)

**Observations**:

-   The trend lines are exactly the same (see Appendix for proof), even though different seasonal components were extracted.

-   `stl()` has combined both the daily and the weekly seasonality into
    it's 'seasonal' component.

-   The daily seasonal component of `mstl()` very clearly shows the
    morning/evening 'sub-peaks', possibly showing effects such as e.g.
    when people wake up and turn on the kettle.

-   The weekly seasonal component has picked shows a "scaly hump"
    pattern.

-   The residuals still show clear cyclical patterns, changing almost every
    week. This suggests there is significant autocorrelation and
    week-by-week seasonality left in the data.

-   The residuals show a noticeable downward spike on the right, showing
    the effect of Waitangi Day. This is the largest single effect
    noticeable in the residuals. The effect is in the morning in particular, presumably as people sleep in and use less electricity in the mornings!

-   The residuals are identical in both `stl()` and `mstl()` (see
    Appendix for proof).

## Decomposition using STR()

Figure 5 on the following page shows decomposition using `STR()`. `AutoSTR()` was used with `gapCV` set to 48.

The STR() decomposition shows, from the top down:

-   A red "trend" component overlaid on the raw data.This component
    appears to be a collection of lines.

-   A daily seasonal component. Compared to the daily component from
    `mstl()`, it is noticeably missing the morning sub-peak and only
    extracting the evening sub-peak.

-   A weekly seasonal component. Compared to `mstl()`, this is *much*
    "spikier"! This might be implying that electricity usage in the
    mornings could actually be more of a weekly effect than a daily effect.
    For example, it could mean that people wake up at different times
    depending on the day of the week, but may tend to go to sleep at around the same time.

-   A random (i.e. residual) component. It shares similarities with the
    ones from `stl()` and `mstl()`, however there are again slight
    differences. In particular, the 'Waitangi day residual', while still
    pronounced, is less so compared to `mstl()`.

-   A fit/forecast in blue, which is a combination of the above seasonal
    and trend components. This is what information the model has
    extracted.

```{r echo=FALSE}
elec_str <- AutoSTR(elec_msts, gapCV = 48, confidence = NULL)
```

\blandscape
\newpage

```{r echo=FALSE, fig.width=11.69, fig.height=8.27, echo=FALSE, dpi=300, fig.cap="STR Decomposition of New Zealand electricity demand from 5 December 2022."}
plot(elec_str)
```

\elandscape
\newpage

## Comparisons

### Features picked out

Both methods picked out very similar features. However as discussed:

1)  `stl()`/`mstl()` emphasized a 'Waitangi day effect' in the residuals
    more than `STR()` In general, it is better able to identify 'local outliers' compared with `STR()`. Another example is the the high peak the Thursday before Waitangi: this is picked up as an obvoious blip in the `mstl()` residuals, but is not readily apparent in the `STR()` residuals. This shows that `mstl()` may be more useful for anomaly/holiday detection.

2)  `STR()` extracted the 'morning sub-peak' into its
    weekly component instead of the daily component as was done
    with `stl()`. Because it is model-based rather than non-parametric this may indicate some interaction effect between mornings and days of the week.

Given these methods pick out different features, they are not necessarily replacements, and could be used to complement each other.

### Analysis of Residuals

The PACF/ACF of each decomposition's residuals will be plotted in Figure 6 (page over), followed by a discussion. Recall that `mstl()` has identical residuals with `stl()`, so the residuals from only one of these needs to be analysed.

\blandscape
\newpage

```{r echo=FALSE, fig.width=11, fig.height=8, fig.cap="ACF and PACF plots of residuals for stl/mstl and STR decompositions", warning=FALSE}
par(mfrow=c(2,2), mar=c(4,4,3,1), oma=c(0,0,3,0))

remainder_stl <- elec_stl$time.series[, "remainder"]


pacf(remainder_stl, main="", ylab="PACF")
title("PACF of residuals of stl/mstl", line=1)

acf(remainder_stl, main="", ylab="ACF")
title("ACF of residuals of stl/mstl", line=1)

remainder_str <- unlist(elec_str$output$random)

pacf(remainder_str, main="", ylab="PACF")
title("PACF of residuals of STR", line=1)

acf(remainder_str, main="", ylab="ACF")
title("ACF of residuals of STR", line=1)

mtext("ACF and PACF plots of residuals", outer=TRUE, cex=1.5, line=1)
```

\elandscape
\newpage

**Similarities**

The PACF plots are mostly similar, shows very high first and second
lags (strongly indicating an AR(1) or AR(2) model may be appropriate).

The ACF plots likewise tail off, giving further evidence that an AR model could fit both sets of residuals.

The first ACF and PACF lag is very strong in both models. This suggests that each point has a very strong correlation to the point immediately before it. This makes sense, as the electricity usage half an hour ago is likely very similar to the current usage.

Lags 3, 5, 7 are also significant in both PACF graphs, which possibly means there are higher AR terms, or even an MA component. 

**Differences**

There are more points outside the lines of significance in the `STR()` ACF/PACF plots, showing that it is not capturing some autocorrelational structures in the data. The 9th lag in the `STR()` PACF plot is much more noticeable compared to in the `mstr()` plot. This may be due to noise, but could also indicate that electricity usage 4.5 hours ago provides more information about electricity usage now, even accounting for the past half-hour's data, which is not implausible.

`mstl()` has captured more of the variance in the data. This possible means that it is just overfitting to the noise, however, since it is non-parametric and just fits smooth curves to the data.

Overall, both ACF/PACF plots of the residuals are similar, showing a strong autocorrelational AR(1)/AR(2) structure, with only small differences due to the way these methods model their components.

### Benchmark

```{r echo=FALSE, fig.cap="Time Comparison of stl, mstl, and str on the dataset. The `microbenchmark` package was used, and each method was repeated 5 times."}
library(microbenchmark,)

# Ensure elec_ts and elec_msts are defined as before

benchmark_results <- microbenchmark(
  stl = stl(elec_ts, s.window="periodic"),
  mstl = mstl(elec_msts, s.window="periodic"),
  str = AutoSTR(elec_msts, gapCV = 48, confidence = 0.95),
  times = 2
)

#print(benchmark_results)

autoplot(benchmark_results)
```

Figure 7 shows that `stl()` is at least 5 orders of magnitude
slower than `STR()` on this dataset. In particular, `stl()` takes around 1ms to run, `mstl()` takes around 5ms, and `STR()` takes over a minute!

This means that if speed is required: for example if new decompositions are required rapidly such as in a production system where electricity demand is constantly predicted using new data, then the LOESS-based methods will definitely have an advantage. 

Since `STR()` performs regression over a sparse matrix, it is theoretically possible that it could be optimized by using a GPU, however I would need to do more investigation on this. Dokumentov mentions a way to achieve higher performance using 'Intel MKL' at the bottom of his vignette (Dokumentov, 2024).

# Conclusions

`STR()` appears to be better fit for the purpose if the goal is to
understand electricity demand. Out of the box it provides an easily
readable plot of the seasonal components, provides interesting insight into how mornings affect electricity demand, and the confidence intervals
are an added bonus. However, it is several orders of magnitude slower
than `stl()`. Furthermore, while it picks up some features/residuals such as the Waitangi day residual, certain residuals no not feature as prominently compared with `stl()`, which may perform 'local' anomaly detection better.

Overall, it seems that both tsechniques are valuable, can complement each other, and both have their place in the time series analyst's toolkit depending on the use case.

## Possible Extensions

There are many possible extensions to the above analyses. Some could be:

-   Performing an analysis over a period relatively devoid of holidays/structural breaks to see how it performs.
-   Performing an analysis for long-term data, where yearly effects
    could be incorporated.
-   Incorporating a temperature covariate to the models.
-   Incorporating holidays as an additional component.
-   Using the logged data instead.
-   Comparing the forecasted results.
-   Combining decompositions, for example using `STR()` first then decomposing the residuals using `mstl()`.
-   Investigate how each demand component (households/commercial/industry) contributes to overall electrical demand in New Zealand.

# Bibliography

Cleveland, R. B., Cleveland, W. S., McRae, J. E., & Terpenning, I. J.
(1990). STL: A seasonal-trend decomposition procedure based on loess.
Journal of Official Statistics, 6(1), 3–33. <http://bit.ly/stl1990>

Dokumentov, A. (2024). Package stR Vignette. CRAN. https://cran.r-project.org/web/packages/stR/vignettes/stRvignette.html

Hyndman, R. J., & Athanasopoulos, G. (2018). Forecasting: Principles and Practice (2nd ed.). OTexts. Chapter on "Complex Seasonality" https://otexts.com/fpp2/complexseasonality.html

Manani, K. (2022). Multi-Seasonal Time Series Decomposition Using MSTL in Python. Towards Data Science. https://towardsdatascience.com/multi-seasonal-time-series-decomposition-using-mstl-in-python-136630e67530

MBIE [Ministry of Business, Innovation & Employment.] (2024). Electricity statistics. New Zealand Government. https://www.mbie.govt.nz/building-and-energy/energy-and-natural-resources/energy-statistics-and-modelling/energy-statistics/electricity-statistics/

# Appendix

## `stl()` technical details

`stl()` uses iterative Loess smoothing to obtain an estimate of the
trend. The equation is forms is:

$$y_t = \hat{T}_t + \hat{S}_t + \hat{R}_t$$

where $\hat{T}_t$ is the estimated trend, $\hat{S}_t$ is the estimated seasonality, and $\hat{R}_t$ is the residual/remainder/irregular component.

Next, it cycles through two loops:

- The "outer loop" deals with robustness, and
- the "inner loop" fits the actual components themselves.

The trend is then
re-predicted using just the predicted seasonal components, then the seasonal
component is re-predicted using the predicted trend component. This repeats several times, until there is a suitable convergance of estimated trend and seasonal components.

Note that since it uses loess, it fits a smooth curve but one that is not
necessarily well defined when extrapolating out. Confidence intervals
cannot be predicted since it is "model-free"/non-parametric.

`mstl()` does the same as the above, however there are multiple seasonal components instead:

$$
y_t = \hat{T}_t + \hat{S}_t^{(1)} + \hat{S}_t^{(2)} + \cdots + \hat{S}_t^{(N)} + \hat{R}_t
$$

All the seasonal components are zeroed out, and then built up from the one with the smallest period. After that is done, each component is subtracted out and re-estimated. As with `stl()`, this repeats (using inner and outer loops) until there is suitable convergence.  

For more information along with some beautiful animations please see the excellent blog post by Manani (2022).

## `STR()` technical details

`str` works by ...

## An error running the Robust version

With R at the latest (as of 24/10/10) version: 4.4.1, and `stR` at the
latest version: 0.7, running the 'Robust' version of stR by setting
`robust=TRUE` caused R to either crash unexpectedly or return an error
message.

Specifically, the line
`AutoSTR(elec_msts_all, gapCV = 48, confidence = NULL, robust=TRUE)`
will crash if the number of weeks is set to $10$, and return an error
message if weeks is set to $3$:

- **as(<dgCMatrix>, "dgTMatrix")' is deprecated. Use 'as(.,**
- **"TsparseMatrix")' instead. See help("Deprecated") and**
- **help("Matrix-deprecated").**

Unfortunately, the Robust version was not able to be experimented with. Given more time, the cause of this bug would have been investigated.

## Finding optimal `s.window`/`t.window`

The following code was generated by Claude 3.5 Sonnet, and iterates
through various combinations of `s.window` and `t.window`, plotting
graphs of the results.

```{r}
library(ggplot2)

stl_window_iterator <- function(ts_data, 
                                s_windows = c("periodic", 2, 48, 10000), 
                                t_windows = c(NULL, 48, 1000),
                                robust = FALSE) {
  results <- list()
  plots <- list()
  
  for (s_window in s_windows) {
    for (t_window in t_windows) {
      window_key <- paste("s", s_window, "t", if(is.null(t_window)) "NULL" else t_window, sep="_")
      
      tryCatch({
        # Convert s_window to numeric if it's not "periodic"
        s_window_param <- if(is.character(s_window) && s_window == "periodic") "periodic" else as.numeric(s_window)
        
        stl_result <- stl(ts_data, s.window = s_window_param, t.window = t_window, robust = robust)
        
        # Extract components
        trend <- stl_result$time.series[, "trend"]
        seasonal <- stl_result$time.series[, "seasonal"]
        remainder <- stl_result$time.series[, "remainder"]
        
        # Calculate metrics
        mse <- mean(remainder^2)
        mae <- mean(abs(remainder))
        
        results[[window_key]] <- list(
          stl_object = stl_result,
          mse = mse,
          mae = mae,
          s_window = s_window,
          t_window = t_window
        )
        
        # Create plot
        df <- data.frame(
          Date = time(ts_data),
          Observed = as.vector(ts_data),
          Trend = trend,
          Seasonal = seasonal,
          Remainder = remainder
        )
        
        p <- ggplot(df, aes(x = Date)) +
          geom_line(aes(y = Observed, color = "Observed")) +
          geom_line(aes(y = Trend, color = "Trend")) +
          geom_line(aes(y = Seasonal, color = "Seasonal")) +
          geom_line(aes(y = Remainder, color = "Remainder")) +
          scale_color_manual(values = c("Observed" = "black", "Trend" = "red", 
                                        "Seasonal" = "blue", "Remainder" = "green")) +
          labs(title = paste("STL Decomposition (s.window =", s_window, ", t.window =", 
                             if(is.null(t_window)) "NULL" else t_window, ")"),
               y = "Value", color = "Component") +
          theme_minimal()
        
        plots[[window_key]] <- p
        
        # Display the plot
        print(p)
        
        cat(sprintf("Completed s.window = %s, t.window = %s\n", 
                    as.character(s_window), if(is.null(t_window)) "NULL" else as.character(t_window)))
      }, error = function(e) {
        cat(sprintf("Error with s.window = %s, t.window = %s: %s\n", 
                    as.character(s_window), if(is.null(t_window)) "NULL" else as.character(t_window), e$message))
      })
    }
  }
  
  return(list(results = results, plots = plots))
}
```

```{r}
#UNCOMMENT NEXT LINE TO ITERATE

#output <- stl_window_iterator(elec_ts)
```

## stl() and mstl() have identical residuals and trend

```{r}
# Remainder/Residuals
head(remainder_stl) # stl
head(elec_mstl[, "Remainder"]) # mstl

#Trend
head(elec_stl$time.series[, "trend"])
head(elec_mstl[,"Trend"]) #mstl
```
