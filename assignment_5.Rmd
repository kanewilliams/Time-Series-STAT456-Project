---
title: "Assignment 5 - Comparing Decomposition Techniques: stl(), mstl(), and STR() on New Zealand Electricity Demand Data"
author: "Kane Williams (pkw21@uclive.ac.nz)"
output:
  bookdown::pdf_document2:
    latex_engine: xelatex
    toc: true
  bookdown::html_document2:
    toc: true
    toc_float: true
    highlight: tango
    theme: flatly
header-includes: 
- \usepackage{amsmath}
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
subtitle: "STAT456-24S2 - Time Series and Stochastic Processes"
editor_options:
  markdown:
    wrap: 72
---

```{r echo=FALSE}
source("./src/packages.R")
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
```

# Introduction

For this assignment, a 10-week period of New Zealand's historical
electricity demand will be decomposed using three different methods,
`stl()`, `mstl()`, and `STR()`.

The resulting decompositions will be compared (i) by the features
extracted, (ii) through an analysis of the residuals, and (iii) through
their time taken to run.

It will be discovered that neither class of technique is a replacement for the
other. LOESS-based techniques like `stl()` and `mstl()` are possibly better for local anomaly detection,
and `STR()` is possibly better at picking up 'interaction' effects
between days and weeks. While the LOESS-based techniques are certainly faster, `STR()` has the advantage of being able to easily form confidence intervals. Both techniques belong in the analyst's
toolkit since ultimately both of them pick out different features of the
data.

## Electricity Demand in New Zealand

New Zealand's electrical demand (two thirds of which are from households
and industry (MBIE, 2024)) is influenced by factors such as temperature,
time-of-day, day-of-the-week, day-of-the-year, and the presence of
holidays. This means that there are multiple seasonal components which potentially have
interaction effects with each other. Using the to-be-discussed techniques, it
will be possible to understand how each seasonal
component contributes to overall demand.

## Decomposition Techniques

Three different methods will be used in this paper. All methods decompose additively
(as will be done for this data), but a log/box-cox transformation can be
used if a multiplicative decomposition is required. Below is a brief
summary of each method. For a more technical description of each method
please see the appendix.

### `stl()`/`mstl()` - Seasonal-Trend decomposition using Loess

`stl()` from the stats package is an R function that decomposes time
series into three components: trend, seasonal, and remainder. It is
based on the work of Cleveland (1990) and works by using LOESS (Locally
Estimated Scatterplot Smoothing) to "iteratively refine estimates" of
each component. The method was designed to be (i) simple to use, (ii)
fast to compute, and (iii) allow for specifying seasonal/trend smoothing
in a continuous way. It was designed for only a single seasonal
component, although it can be adapted for multiple seasonalities either
through nested applications or by using the related `mstl()` function
from the `forecast` package. `stl()` and `mstl()` are non-parametric
methods not based on any statistical model. They just attempt to fit
smooth curves to the data.

### `STR()` - Seasonal-Trend decomposition using Regression

`STR()` from the stR package is an R function developed by Dokumentov
and Hyndman (2021) that decomposes time series into multiple seasonal
components. It is "based on a regularized optimization, and is related
to ridge regression". It attempts to address limitations in other
methods by allowing for not only multiple seasonal patterns, but also
(i) non-integer periods, (ii) complex topologies such as modelling
holidays, (iii) covariates such as temperature and the presence of
COVID-19, and even (iv) interaction effects between the seasonal
components and the covariates. Furthermore, as it is based on a
statistical model, confidence intervals can be computed.

# Data

## Data Description

The dataset chosen was: **Demand trends**, pulled on `1 October 2024`
from the [Electricity
Authority](https://www.emi.ea.govt.nz/Wholesale/Reports/W_GD_C?DateFrom=20190901&DateTo=20240831&RegionType=NZ&_rsdr=L60M&_si=_dr_DateFrom%7C20140101,_dr_DateTo%7C20231231,_dr_RegionType%7CNZ,_dr__rsdr%7CL10Y,v%7C4)
with the following parameters:

-   **Date Range**: 01 Jan 2014 - 31 Dec 2023
-   **Region Type**: New Zealand
-   **Time Scale** Trading Period (i.e. half-hourly data)

Note that the unit of measurement is GWh (Gigawatt hours).

This data will then be reduced to the 10 weeks beginning from
`5 December 2022`. This date was chosen because it (i) includes the
Christmas period, which will be a good test for how each technique deals
with "Holiday" effects, and (ii) conveniently begins on a Monday, which
may make the plots easier to interpret.

10 weeks was chosen because it is small enough that it is easy to
visually identify both weekly and daily periods, and it is large enough
to exhibit multiple-seasonality from both of these periods.

Before decomposing it, it will be useful to get a feel for the data by
plotting it (Figure 1 and 2 below) and recording any noticeable observations.

```{r echo=FALSE}
# READ data
file_path <- "./data/NZ_Electricity_Demand_2014-2023.csv"
header <- c("Period_Start", "Period_End", "Region_ID", "Region", "Price")

raw_data <- read_csv(file_path, 
                     skip = 12, 
                     col_names = header,
                     show_col_types = FALSE) %>%
  mutate(
    Price = as.numeric(Price),
    Period_Start = dmy_hms(Period_Start),
    Period_End = dmy_hms(Period_End)
  )
```

```{r echo=FALSE}
# FILTER relevant rows and columns
elec_data <- raw_data %>%
  dplyr::select(Period_Start, Price) %>%
  dplyr::filter(Period_Start >= as.Date("2022-12-05") & 
                Period_Start < as.Date("2022-12-05") + weeks(10))
```

## Time Series Plots

```{r time-series-plot, echo=FALSE, fig.cap="Plot of New Zealand Electrical Demand over Christmas '22. Source: Electricity Authority"}
ggplot(elec_data, aes(x = Period_Start, y = Price)) +
  geom_line() +
  geom_vline(xintercept = as.POSIXct("2022-12-25"), color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2022-12-25"), y = max(elec_data$Price), 
           label = "Christmas", color = "red", vjust = 2, hjust = -0.1) +
  # geom_vline(xintercept = as.POSIXct("2023-02-07"), color = "blue", linetype = "dashed", size = 0.5) +
  # annotate("text", x = as.POSIXct("2023-02-07"), y = max(elec_data$Price), 
  #          label = "Waitangi Public Holiday", color = "blue", vjust = 2, hjust = -0.1) +
  labs(
    title = "New Zealand Electrical Demand",
    subtitle = "10 weeks from December 5, 2022",
    y = "Electricity Demand (GWh)"
  ) +
  xlab("") + # no x label
  theme(
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  scale_x_datetime(date_breaks = "1 week", date_labels = "%b %d")
```

```{r time-series-plot2, echo=FALSE, fig.cap="Fully labelled NZ Electrical Demand over Christmas '22. Green line represents Wellington's Anniversary - a regional holiday - and the blue line represents Auckland's Anniversary. The pink band represents when Cyclone Gabriel may have impacted New Zealand. All holidays are labelled on the day observed."}
ggplot(elec_data, aes(x = Period_Start, y = Price)) +
  geom_rect(aes(xmin = as.POSIXct("2023-02-05"), xmax = as.POSIXct("2023-02-14"), 
              ymin = -Inf, ymax = Inf), fill = "pink", alpha = 0.2) +
  geom_line() +
  geom_vline(xintercept = as.POSIXct("2023-01-03"), color = "orange", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2023-01-03"), y = max(elec_data$Price),
           label = "New Years", color = "orange", vjust = 1, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2022-12-25"), color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2022-12-25"), y = max(elec_data$Price), 
           label = "Christmas", color = "red", vjust = 2, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2023-02-07"), color = "black", linetype = "dashed", linewidth = 1) +
  annotate("text", x = as.POSIXct("2023-02-07"), y = max(elec_data$Price),
           label = "Waitangi", color = "black", vjust = 1, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2023-01-31"), color = "blue", linetype = "dashed", linewidth = 1) +
  # annotate("text", x = as.POSIXct("2023-01-31"), y = max(elec_data$Price),
  #          label = "Auckland Annv.", color = "blue", vjust = 2, hjust = -0.1) +
  geom_vline(xintercept = as.POSIXct("2023-01-24"), color = "darkgreen", linetype = "dashed", linewidth = 1) +
  # annotate("text", x = as.POSIXct("2023-01-24"), y = max(elec_data$Price),
  #          label = "Wellington Annv.", color = "darkgreen", vjust = 3, hjust = -0.1) +
  annotate("text", x = as.POSIXct("2023-02-08"), y = min(elec_data$Price),
           label = "Cyclone", color = "deeppink", vjust = -1, hjust = -0) +
  labs(
    title = "New Zealand Electrical Demand (fully labelled)",
    subtitle = "10 weeks from December 5, 2022",
    y = "Electricity Demand (GWh)"
  ) +
  xlab("") + # no x label
  theme(
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  scale_x_datetime(date_breaks = "1 week", date_labels = "%b %d")
```

**Noticeable observations**

There is clear daily and weekly seasonality present (recall that the
data begins on a Monday):

-   There is daily variation of around 0.5-1 GWh, with peaks during the
    day and troughs during the night. Furthermore, there appears to be
    smaller sub-peaks around the mornings — possibly as households start waking up — and evenings.

-   Weekly seasonality is most noticeable by the dip in demand over the
    weekends (by $\sim0.5 \texttt{GWh}$ on average). This is possibly due to industry closing down over the weekend.

As for holidays:

-   The Christmas/New Years holiday period had a very noticeable impact
    on electricity demand, with a sudden drop of around 0.5-1 GWh
    leading up to Christmas, and a gradual buildup to previous
    electricity demand in the weeks afterwards.

-   Furthermore, Waitangi day (a New Zealand public holiday) was
    observed on the 7th of February 2022. Its effect is not immediately
    obvious in the above plot, but will be made clearer with the
    decompositions.

# Method

First, results from the three decomposition methods: `stl()`, `mstl()`,
and `STR()` will be presented and briefly discussed. Since the data
shows only a mild linearly increasing trend (and only in the last 7 weeks),
an additive model will be assumed and the methods will be applied to the
raw (rather than the logged) data. Afterwards, they will be compared in
three ways:

1)  By what features they pick out,
2)  By an ACF/PACF investigation of their residuals, and
3)  By how long each method takes to run.

Lastly, practical implications will be discussed as well as possible
extensions to this analysis.

# Result

```{r echo=FALSE}

# The data is first converted to a `ts` (time series) object for `stl()`,
# and an `msts` (multi-seasonal time series) object for `mstl()` and
# `STR()`.

season_day <- 48 # day
season_week <- 48 * 7 # week
season_year <- 48 * 7 * 52.25 # year

elec_ts <- ts(elec_data$Price,
                     frequency = season_week 
)

elec_msts <- forecast::msts(as.vector(elec_data$Price), 
                             seasonal.periods = c(season_day, season_week, season_year)
)
```

## Decomposition using stl() and mstl()

Note: `stl()` and `mstl()` require setting the 'smoothing parameters'
`s.window` for the seasonal component, and `t.window` for the trend
component. The higher the smoothing window, the less variation will be
picked up. The lower the smoothing window the more variation will be
picked.

After experimenting with several combinations (see Appendix), the
default `t.window` and an `s.window` of "periodic" was decided. This
combination balanced between overfitting on variation in the data while
nevertheless capturing the overall trend and pattern.

The `s.window` and `t.window` parameters were set with the exact same
settings for `mstl()` for a fair comparison.

\newpage
\blandscape

```{r fig.width=11, fig.height=8, echo=FALSE, dpi=300, fig.cap="STL Decomposition with a weekly period, s.window=periodic"}
elec_stl <- stl(elec_ts, s.window="periodic")
elec_stl %>% autoplot() + 
  ggtitle("STL Decomposition with a weekly period, s.window=periodic") +
  theme(plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        strip.text = element_text(size = 14),
        plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"))
```

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r fig.width=11, fig.height=8, echo=FALSE, dpi=300, fig.cap="MSTL Decomposition with weekly/daily periods, s.window=periodic"}
elec_mstl <- mstl(elec_msts, s.window="periodic")
p <- elec_mstl %>% autoplot() + 
  ggtitle("MSTL Decomposition with weekly/daily periods, s.window=periodic") +
  theme(plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12),
        strip.text = element_text(size = 14),
        plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"))

# p <- p + geom_hline(data = data.frame(parts = "Remainder", y = 0),
#                     aes(yintercept = y),
#                     linetype = "solid",
#                     color = "black")

p
```

\newpage
\elandscape

Figure 3 and Figure 4 on the previous pages show decompositions using
`stl()` and `mstl()`. (Unfortunately, the residuals are plotted differently due to how `autoplot` plots graphs. I spent some time trying to fix this, but could not get the residual-plots into the same format without affecting the trend/seasonal plots. Given more time I would try to fix this.)

**Observations**:

-   The trend lines and residuals are exactly the same (see Appendix for proof), even though different seasonal components were extracted.

-   `stl()` has combined both the daily and the weekly seasonality into
    its 'seasonal' component.

-   All seasonal components clearly show
    morning/evening 'sub-peaks', possibly showing effects such as e.g.
    when people wake up and turn on the kettle.

-   The weekly seasonal component has picked shows a "scaly hump"
    pattern.

-   The residuals still show clear cyclical patterns, changing almost every
    week. This suggests there is significant autocorrelation remaining, and
    week-be-week seasonality (not shared across all weeks) left in the data.

-   The residuals show a noticeable downward spike on the right, showing
    the effect of Waitangi Day. This is the largest single effect
    noticeable in the residuals. The effect is in the morning in particular, presumably as people sleep in and use less electricity in the mornings!

## Decomposition using STR()

Figure 5 on the following page shows decomposition using `STR()`. `AutoSTR()` was used with `gapCV` set to 48. Note that there is a Robust version of `STR()` that better handles outliers, but due to technical difficulties it was not able to be experimented with, see the appendix for more.

The STR() decomposition shows, from the top down:

-   A red "trend" component overlaid on the raw data.This component
    appears to be a collection of lines.

-   A daily seasonal component. Compared to the daily component from
    `mstl()`, it is noticeably missing the morning sub-peak and only
    extracting the evening sub-peak.

-   A weekly seasonal component. Compared to `mstl()`, this is *much*
    "spikier"! This might be implying that electricity usage in the
    mornings could actually be more of a weekly effect than a daily effect.
    For example, it could mean that people wake up at different times
    depending on the day of the week, but may tend to go to sleep at around the same time.

-   A random (i.e. residual) component. It shares similarities with the
    ones from `stl()` and `mstl()`, however there are again slight
    differences. In particular, the 'Waitangi day residual', while still
    pronounced, is less so compared to `mstl()`.

-   A fit/forecast in blue, which is a combination of the above seasonal
    and trend components. This is what information the model has
    extracted.

```{r echo=FALSE}
elec_str <- AutoSTR(elec_msts, gapCV = 48, confidence = NULL)
```

\blandscape
\newpage

```{r echo=FALSE, fig.width=11.69, fig.height=8.27, echo=FALSE, dpi=300, fig.cap="STR Decomposition of New Zealand electricity demand from 5 December 2022."}
plot(elec_str)
```

\elandscape
\newpage

## Comparisons

### Features picked out

Both methods picked out very similar features. However as discussed:

1)  `stl()`/`mstl()` emphasized a 'Waitangi day effect' in the residuals
    more than `STR()` In general, it is better able to identify 'local outliers' compared with `STR()`. Another example is the the high peak the Thursday before Waitangi: this is picked up as an obvious blip in the `mstl()` residuals, but is not readily apparent in the `STR()` residuals. This shows that `mstl()` may be more useful for local anomaly/holiday detection.

2)  `STR()` extracted the 'morning sub-peak' into its
    weekly component instead of the daily component as was done
    with `stl()`. Because it is model-based rather than non-parametric this may indicate some interaction effect between mornings and days of the week.

Given these methods pick out different features, they are not necessarily replacements, and could be used to complement each other.

### Analysis of Residuals

The PACF/ACF of each decomposition's residuals will be plotted in Figure 6 (page over), followed by a discussion. Recall that `mstl()` has identical residuals with `stl()`, so the residuals from only one of these needs to be analysed.

\blandscape
\newpage

```{r echo=FALSE, fig.width=11, fig.height=8, fig.cap="ACF and PACF plots of residuals for stl/mstl and STR decompositions", warning=FALSE}
par(mfrow=c(2,2), mar=c(4,4,3,1), oma=c(0,0,3,0))

remainder_stl <- elec_stl$time.series[, "remainder"]


pacf(remainder_stl, main="", ylab="PACF")
title("PACF of residuals of stl/mstl", line=1)

acf(remainder_stl, main="", ylab="ACF")
title("ACF of residuals of stl/mstl", line=1)

remainder_str <- unlist(elec_str$output$random)

pacf(remainder_str, main="", ylab="PACF")
title("PACF of residuals of STR", line=1)

acf(remainder_str, main="", ylab="ACF")
title("ACF of residuals of STR", line=1)

mtext("ACF and PACF plots of residuals", outer=TRUE, cex=1.5, line=1)
```

\elandscape
\newpage

**Similarities**

The PACF plots are mostly similar, showing very high first and second
lags (strongly indicating that an AR(1) or AR(2) model may be appropriate).

The ACF plots likewise tail off, giving further evidence that an AR model could fit both sets of residuals.

The first ACF and PACF lag is very strong in both models. This suggests that each point has a very strong correlation to the point immediately before it. This makes sense, as the electricity usage half an hour ago is likely very similar to the current usage.

Lags 3, 5, 7 are also significant in both PACF graphs, which possibly means there are higher order AR terms, or even MA components. 

**Differences**

There are more points outside the lines of significance in the `STR()` ACF/PACF plots, showing that `STR()` is arguably not capturing more autocorrelational structures in the data compared to `mstl()`.

The 9th lag in the `STR()` PACF plot is much more noticeable compared with the `mstr()` PACF plot. This may be due to noise, but could also indicate that electricity usage 4.5 hours ago provides more information about electricity usage now, even accounting for the past half-hour's data, which is not implausible.

`mstl()` has captured more of the variance in the data. This possible means that it is just overfitting the data, since it is non-parametric and just fits smooth curves to the data.

Overall, both ACF/PACF plots of both the residuals are similar, showing a strong autocorrelational AR(1)/AR(2) structure, with only small differences due to the way these methods model their components.

### Benchmark

```{r echo=FALSE, fig.cap="Time Comparison of stl, mstl, and str on the dataset. The `microbenchmark` package was used, and each method was repeated 5 times."}
library(microbenchmark,)

# Ensure elec_ts and elec_msts are defined as before

benchmark_results <- microbenchmark(
  stl = stl(elec_ts, s.window="periodic"),
  mstl = mstl(elec_msts, s.window="periodic"),
  str = AutoSTR(elec_msts, gapCV = 48, confidence = 0.95),
  times = 5
)

#print(benchmark_results)

autoplot(benchmark_results)
```

Figure 7 on the next page shows that `stl()` is at least 5 orders of magnitude
slower than `STR()` on this dataset. In particular, `stl()` takes around 1ms to run, `mstl()` takes around 5ms, and `STR()` takes over a minute!

This means that if speed is required: for example if new decompositions are required rapidly such as in a production system where electricity demand is constantly predicted using new data, then the LOESS-based methods will definitely have an advantage. 

Since `STR()` performs regression over a sparse matrix, it is theoretically possible that it could be optimized by using a GPU, however I would need to do more investigation on this. Dokumentov mentions a way to achieve higher performance using 'Intel MKL' at the bottom of his vignette (Dokumentov, 2024).

# Conclusions

`STR()` initially appears to be better fit for the purpose if the goal is to
understand electricity demand. Out of the box it provides an easily
readable plot of the seasonal components, provides interesting insight into how mornings affect electricity demand, and the confidence intervals
are an added bonus. However, it is several orders of magnitude slower
than `stl()`. Furthermore, while it picks up some features/residuals such as the Waitangi day residual, this and other features/holidays do not show up as prominently in the residual plot compared with `stl()`, showing that `stl()` may perform 'local' anomaly detection better.

Overall, it seems that both techniques are valuable, can complement each other, and both have their place in the time series analyst's toolkit depending on the use case.

## Next Steps

There are many ways to extend the above analyses. Some candidates are:

-   Performing an analysis over an uneventful period.
-   Performing an analysis for long-term data with yearly seasonal effects.
-   Incorporating temperature/holiday covariates to the models.
-   Comparing the forecasted results.
-   Combining decompositions, for example using `STR()` first then decomposing the residuals using `mstl()`.
-   Investigate how each demand component (households/commercial/industry) contributes to overall electrical demand in New Zealand.

# Bibliography

Bandara, K., Hyndman, R. J., & Bergmeir, C. (2021). MSTL: A Seasonal-Trend Decomposition Algorithm for Time Series with Multiple Seasonal Patterns. arXiv preprint arXiv:2107.13462.

Cleveland, R. B., Cleveland, W. S., McRae, J. E., & Terpenning, I. J.
(1990). STL: A seasonal-trend decomposition procedure based on loess.
Journal of Official Statistics, 6(1), 3–33. <http://bit.ly/stl1990>

Dokumentov, A. (2024). Package stR Vignette. CRAN. https://cran.r-project.org/web/packages/stR/vignettes/stRvignette.html

Hyndman, R. J., & Athanasopoulos, G. (2018). Forecasting: Principles and Practice (2nd ed.). OTexts. Chapter on "Complex Seasonality" https://otexts.com/fpp2/complexseasonality.html

Manani, K. (2022). Multi-Seasonal Time Series Decomposition Using MSTL in Python. Towards Data Science. https://towardsdatascience.com/multi-seasonal-time-series-decomposition-using-mstl-in-python-136630e67530

MBIE [Ministry of Business, Innovation & Employment.] (2024). Electricity statistics. New Zealand Government. https://www.mbie.govt.nz/building-and-energy/energy-and-natural-resources/energy-statistics-and-modelling/energy-statistics/electricity-statistics/

# Appendix

## `stl()` technical details

`stl()` uses iterative Loess smoothing to obtain an estimate of the
trend. The equation it forms is:

$$y_t = \hat{T}_t + \hat{S}_t + \hat{R}_t$$

where $\hat{T}_t$ is the estimated trend, $\hat{S}_t$ is the estimated seasonality, and $\hat{R}_t$ is the residual/remainder/irregular component.

First, it initializes these estimates. Next, it cycles through two loops:

- The "outer loop" deals with robustness, and
- the "inner loop" fits the actual components themselves.

The trend is then
re-predicted (in the inner loop) using just the predicted seasonal components, then the seasonal
component is re-predicted using the predicted trend component. This repeats several times, until there is suitable convergence of estimated trend and seasonal components.

Note that since it uses loess, it fits a smooth curve but one that is not
necessarily well defined when extrapolating out. Without additional techniques Confidence intervals
cannot be predicted, as it is non-parametric method.

`mstl()` does the same as the above, however there are multiple seasonal components instead:

$$
y_t = \hat{T}_t + \hat{S}_t^{(1)} + \hat{S}_t^{(2)} + \cdots + \hat{S}_t^{(N)} + \hat{R}_t
$$

All the seasonal components are zeroed out, and then built up from the one with the smallest period. After that is done, each component is subtracted out and re-estimated. As with `stl()`, this repeats (using inner and outer loops) until there is suitable convergence.  

For more information along with some beautiful animations please see the excellent blog post by Manani (2022).

## `STR()` technical details

`STR()` decomposes a time series plot into the following components:

$$
y_t = T_t + \sum_{i=1}^I S_t^{(i)} + \sum_{p=1}^P \phi_{p,t}z_{t,p} + R_t,
$$

where $T_t$ is the trend, $S_t^{(i)}$ are the various seasonal components, $\phi_{p,t}z_{t,p}$ represent covariate effects (such as temperature), and $R_t$ is the residual component. Its equation is deceptively similar to the one for `stl()`, even though the underlying technique is entirely different.

`STR()` works by performing an optimization, similar to minimizing least squares, over a large sparse matrix. This matrix contains information about "smoothness" of the Trend and Seasonal components. Smoothness means that the second derivative of each component is small. In particularly, the second derivative is drawn from $\mathcal{N}(0, \sigma^2)$ where the variance $\sigma^2$ acts like a smoothing hyperparameter.

Thus as an example, a sawtooth-like wave would not be a good fit for a seasonal component because it would have many sharp turns and the second derivative would not fit as described.

Since `STR()` is parametric and actually assumes something about the data (in particular that it has "smooth" components), `STR()` has the ability to produce confidence intervals.

Furthermore, `STR()` also has:

- A **Regularization** term in the optimization equation, which the authors claim makes `STL()` perform a type of ridge regression.

- The usage of **Cross-Validation** to find the optimal hyperparameters, and

- The ability to define **Semi-Arbitrary Topologies**, for example (i) to include working holidays, and (ii) yearly seasonal effects. This is done by defining 'Knots' in the code.

For more information, please refer to the original paper by Dokumentov and Hyndman (2021), or the vignette by Dokumentov (2024).

## An error running the Robust version

With R version: 4.4.1, and `stR` at the
latest version: 0.7, running the 'Robust' version of stR by setting
`robust=TRUE` caused R to either crash unexpectedly or return an error
message.

Specifically, the line
`AutoSTR(elec_msts_all, gapCV = 48, confidence = NULL, robust=TRUE)`
will crash if the number of weeks is set to $10$, and return an error
message if weeks is set to $3$:

- **as(<dgCMatrix>, "dgTMatrix")' is deprecated. Use 'as(.,**
- **"TsparseMatrix")' instead. See help("Deprecated") and**
- **help("Matrix-deprecated").**

Unfortunately due to time, the Robust version was not able to be experimented with. With more time, the cause of this bug would have been more thoroughly investigated.

## Finding optimal `s.window`/`t.window`

The following code was generated by Claude 3.5 Sonnet, and iterates
through various combinations of `s.window` and `t.window`, plotting
graphs of the results.

```{r}
library(ggplot2)

stl_window_iterator <- function(ts_data, 
                                s_windows = c("periodic", 2, 48, 10000), 
                                t_windows = c(NULL, 48, 1000),
                                robust = FALSE) {
  results <- list()
  plots <- list()
  
  for (s_window in s_windows) {
    for (t_window in t_windows) {
      window_key <- paste("s", s_window, "t", if(is.null(t_window)) "NULL" else t_window, sep="_")
      
      tryCatch({
        # Convert s_window to numeric if it's not "periodic"
        s_window_param <- if(is.character(s_window) && s_window == "periodic") "periodic" else as.numeric(s_window)
        
        stl_result <- stl(ts_data, s.window = s_window_param, t.window = t_window, robust = robust)
        
        # Extract components
        trend <- stl_result$time.series[, "trend"]
        seasonal <- stl_result$time.series[, "seasonal"]
        remainder <- stl_result$time.series[, "remainder"]
        
        # Calculate metrics
        mse <- mean(remainder^2)
        mae <- mean(abs(remainder))
        
        results[[window_key]] <- list(
          stl_object = stl_result,
          mse = mse,
          mae = mae,
          s_window = s_window,
          t_window = t_window
        )
        
        # Create plot
        df <- data.frame(
          Date = time(ts_data),
          Observed = as.vector(ts_data),
          Trend = trend,
          Seasonal = seasonal,
          Remainder = remainder
        )
        
        p <- ggplot(df, aes(x = Date)) +
          geom_line(aes(y = Observed, color = "Observed")) +
          geom_line(aes(y = Trend, color = "Trend")) +
          geom_line(aes(y = Seasonal, color = "Seasonal")) +
          geom_line(aes(y = Remainder, color = "Remainder")) +
          scale_color_manual(values = c("Observed" = "black", "Trend" = "red", 
                                        "Seasonal" = "blue", "Remainder" = "green")) +
          labs(title = paste("STL Decomposition (s.window =", s_window, ", t.window =", 
                             if(is.null(t_window)) "NULL" else t_window, ")"),
               y = "Value", color = "Component") +
          theme_minimal()
        
        plots[[window_key]] <- p
        
        # Display the plot
        print(p)
        
        cat(sprintf("Completed s.window = %s, t.window = %s\n", 
                    as.character(s_window), if(is.null(t_window)) "NULL" else as.character(t_window)))
      }, error = function(e) {
        cat(sprintf("Error with s.window = %s, t.window = %s: %s\n", 
                    as.character(s_window), if(is.null(t_window)) "NULL" else as.character(t_window), e$message))
      })
    }
  }
  
  return(list(results = results, plots = plots))
}
```

```{r}
#UNCOMMENT NEXT LINE TO ITERATE

#output <- stl_window_iterator(elec_ts)
```

## stl() and mstl() have identical residuals and trend

```{r}
# Remainder/Residuals
head(remainder_stl) # stl
head(elec_mstl[, "Remainder"]) # mstl

#Trend
head(elec_stl$time.series[, "trend"])
head(elec_mstl[,"Trend"]) #mstl
```
